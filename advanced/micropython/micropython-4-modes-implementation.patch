diff --git a/advanced/micropython/README.md b/advanced/micropython/README.md
index 7d79324..4cb523a 100644
--- a/advanced/micropython/README.md
+++ b/advanced/micropython/README.md
@@ -1,15 +1,468 @@
-## Compiling MicroPython
-```
+# MicroPython Port for RISC-V Emulator
+
+This is a MicroPython port for the pure-Python RISC-V emulator, supporting multiple build modes for different embedded scenarios.
+
+## Build Modes
+
+The port supports 4 configurable modes, selected at compile time via the `MODE` variable:
+
+| Mode | Description | I/O Method | Float Support | REPL | Frozen Script |
+|------|-------------|------------|---------------|------|---------------|
+| **REPL_SYSCALL** | Interactive development | read()/write() syscalls | ✅ Yes | ✅ Yes | ❌ No |
+| **EMBEDDED_SILENT** | Embedded script only | Silent (no I/O) | ❌ No | ❌ No | ✅ Yes |
+| **REPL_UART** | Interactive over UART | UART MMIO (0x10000000) | ❌ No | ✅ Yes | ❌ No |
+| **EMBEDDED_UART** | Script + UART REPL | UART MMIO (0x10000000) | ❌ No | ✅ Yes | ✅ Yes |
+
+All modes support:
+- 64-bit integers (for uctypes and large values)
+- uctypes module (memory-mapped I/O)
+- struct, array, collections, re modules
+- Full Python language features (except floats in non-REPL_SYSCALL modes)
+
+---
+
+## Quick Start
+
+### Mode 1: REPL_SYSCALL (Default)
+
+Standard interactive REPL with full float support.
+
+**Build:**
+```bash
 cd port-riscv-emu.py
+make
+# or explicitly:
+make MODE=REPL_SYSCALL
+```
+
+**Run:**
+```bash
+../../riscv-emu.py --raw-tty --ram-size=4096 build/firmware.elf
+```
+
+You'll see:
+```
+Welcome to MicroPython on RISC-V!
+>>> print("Hello World!")
+Hello World!
+>>> import math
+>>> math.pi
+3.141593
+```
+
+---
+
+### Mode 2: EMBEDDED_SILENT
+
+Run a frozen Python script with no I/O (for pure computation tasks).
+
+**Build with a script:**
+```bash
+make MODE=EMBEDDED_SILENT FROZEN_SCRIPT=startup.py clean all
+```
+
+**Run:**
+```bash
+../../riscv-emu.py --ram-size=4096 build/firmware.elf
+```
+
+The script runs silently and exits. Use this mode for:
+- Computation-only tasks
+- Environments without I/O devices
+- Minimal binary size
+
+**Example script (startup.py):**
+```python
+# Integer-only computation
+result = sum([i**2 for i in range(100)])
+# Result stored in memory, can be read by emulator
+```
+
+---
+
+### Mode 3: REPL_UART
+
+Interactive REPL over memory-mapped UART (no syscalls, integer-only).
+
+**Build:**
+```bash
+make MODE=REPL_UART clean all
+```
+
+**Run:**
+```bash
+# Terminal 1: Start emulator with UART
+../../riscv-emu.py --uart --ram-size=4096 build/firmware.elf
+
+# Note the PTY device shown, e.g.: [UART] PTY created: /dev/pts/3
+
+# Terminal 2: Connect to the UART
+screen /dev/pts/3
+# or
+picocom /dev/pts/3
+```
+
+You'll see the MicroPython REPL over the UART:
+```
+Welcome to MicroPython on RISC-V!
+>>> print([i*i for i in range(10)])
+[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
+>>> import uctypes
+```
+
+**Note:** This mode has no float support (integer-only), but is perfect for embedded systems with UART.
+
+---
+
+### Mode 4: EMBEDDED_UART
+
+Run a frozen script, then start REPL over UART.
+
+**Build:**
+```bash
+make MODE=EMBEDDED_UART FROZEN_SCRIPT=startup.py clean all
+```
+
+**Run:**
+```bash
+# Terminal 1: Start emulator
+../../riscv-emu.py --uart --ram-size=4096 build/firmware.elf
+
+# Terminal 2: Connect to UART
+screen /dev/pts/3
+```
+
+The frozen script executes first, then you get an interactive REPL. Perfect for:
+- Initialization scripts followed by debug console
+- Automated setup with interactive testing
+- Production systems with maintenance access
+
+---
+
+## Frozen Scripts
+
+Frozen scripts are Python files compiled to bytecode and embedded in the firmware at build time.
+
+### How It Works
+
+1. **Specify script** via `FROZEN_SCRIPT` variable
+2. **Build** - script is compiled to `.mpy` bytecode
+3. **Embedded** - bytecode converted to C and linked into firmware
+4. **Executed** - runs automatically at startup (modes 2 and 4)
+
+### Example: Custom Frozen Script
+
+Create `my_app.py`:
+```python
+import struct
+import array
+
+print("My Application Starting...")
+
+# Configuration
+config = {
+    'version': 1,
+    'mode': 'production',
+    'buffer_size': 1024
+}
+
+print(f"Config: {config}")
+
+# Do work
+data = array.array('i', range(100))
+total = sum(data)
+print(f"Computed sum: {total}")
+
+print("Application complete")
+```
+
+Build and run:
+```bash
+make MODE=EMBEDDED_UART FROZEN_SCRIPT=my_app.py clean all
+../../riscv-emu.py --uart --ram-size=4096 build/firmware.elf
+# Connect via screen - see app output, then get REPL
+```
+
+---
+
+## Using uctypes for Hardware Access
+
+The `uctypes` module allows direct memory-mapped I/O access from Python, perfect for embedded systems.
+
+### Example: UART via uctypes
+
+The included `uart_demo.py` demonstrates uctypes for UART control:
+
+```python
+import uctypes
+
+# Define UART registers at 0x10000000
+UART_BASE = 0x10000000
+uart_layout = {
+    "TX": uctypes.UINT32 | 0x00,  # Transmit
+    "RX": uctypes.UINT32 | 0x04,  # Receive
+}
+
+# Create UART structure
+uart = uctypes.struct(UART_BASE, uart_layout, uctypes.LITTLE_ENDIAN)
+
+# Write to UART
+def uart_print(s):
+    for c in s:
+        uart.TX = ord(c)
+
+uart_print("Hello from Python!\r\n")
+
+# Read from UART (non-blocking)
+rx_val = uart.RX
+if not (rx_val & 0x80000000):
+    print(f"Received: {chr(rx_val & 0xFF)}")
+```
+
+**Run the demo:**
+```bash
+make MODE=EMBEDDED_SILENT FROZEN_SCRIPT=uart_demo.py clean all
+../../riscv-emu.py --uart --ram-size=4096 build/firmware.elf
+# Connect via screen to see output
+```
 
-# Build with default (RV32IM)
+### Python REPL via uctypes
+
+The included `uart_repl.py` implements a full REPL using only uctypes (no C-level I/O):
+
+```bash
+make MODE=EMBEDDED_SILENT FROZEN_SCRIPT=uart_repl.py clean all
+../../riscv-emu.py --uart --ram-size=4096 build/firmware.elf
+# Connect via screen - get a Python-implemented REPL!
+```
+
+This demonstrates pure-Python hardware control without any syscalls.
+
+---
+
+## Advanced Build Options
+
+### RISC-V Extensions
+
+```bash
+# Default: RV32IM (Integer + Multiply/Divide)
 make
 
-# Build with all extensions (RV32IMAC)
+# Enable Compressed instructions (RV32IMC)
+make RVC=1
+
+# Enable Atomic instructions (RV32IMA)
+make RVA=1
+
+# All extensions (RV32IMAC)
 make RVM=1 RVA=1 RVC=1
 ```
 
-## Running MicroPython
+### Debug Build
+
+```bash
+make DEBUG=1
+```
+
+### Custom Frozen Script
+
+```bash
+make MODE=EMBEDDED_UART FROZEN_SCRIPT=/path/to/my_script.py clean all
+```
+
+**Important:** Always use `clean all` when changing modes to ensure proper rebuild.
+
+---
+
+## Examples
+
+### 1. Interactive Math (REPL_SYSCALL)
+
+```bash
+make MODE=REPL_SYSCALL
+../../riscv-emu.py --raw-tty --ram-size=4096 build/firmware.elf
+```
+
+```python
+>>> import math
+>>> math.sqrt(2)
+1.414214
+>>> [math.sin(x/10) for x in range(10)]
+```
+
+### 2. Data Processing Script (EMBEDDED_SILENT)
+
+Create `process.py`:
+```python
+import array
+
+# Process sensor data
+readings = array.array('i', [23, 45, 67, 12, 89, 34])
+average = sum(readings) // len(readings)
+maximum = max(readings)
+minimum = min(readings)
+
+# Results in memory for emulator to read
+```
+
+```bash
+make MODE=EMBEDDED_SILENT FROZEN_SCRIPT=process.py clean all
+../../riscv-emu.py --ram-size=4096 build/firmware.elf
+```
+
+### 3. Hardware Control (REPL_UART + uctypes)
+
+```bash
+make MODE=REPL_UART clean all
+../../riscv-emu.py --uart --ram-size=4096 build/firmware.elf
+# In another terminal:
+screen /dev/pts/X
+```
+
+In the REPL:
+```python
+>>> import uctypes
+>>> # Define memory-mapped LED at 0x20000000
+>>> led = uctypes.struct(0x20000000, {"ctrl": uctypes.UINT32 | 0}, uctypes.LITTLE_ENDIAN)
+>>> led.ctrl = 1  # Turn on LED
+>>> led.ctrl = 0  # Turn off LED
+```
+
+### 4. Bootloader + Debug Console (EMBEDDED_UART)
+
+Create `bootloader.py`:
+```python
+import struct
+
+print("Bootloader v1.0")
+print("Checking system...")
+
+# Check configuration
+config_addr = 0x1000
+config = struct.unpack_from('III', bytes(12), 0)
+print(f"Config: {config}")
+
+print("Boot complete. Entering debug mode...")
+```
+
+```bash
+make MODE=EMBEDDED_UART FROZEN_SCRIPT=bootloader.py clean all
+../../riscv-emu.py --uart --ram-size=4096 build/firmware.elf
+# Bootloader runs, then get interactive REPL for debugging
+```
+
+---
+
+## Troubleshooting
+
+### Build Errors
+
+**"micropython submodule not initialized"**
+```bash
+cd ../micropython
+git submodule update --init
+cd ../port-riscv-emu.py
+```
+
+**"mpy-cross not found"**
+Build mpy-cross tool:
+```bash
+cd ../micropython/mpy-cross
+make
+cd ../../port-riscv-emu.py
+```
+
+### Runtime Issues
+
+**"UART not working"**
+- Ensure emulator is started with `--uart` flag
+- Check the PTY device name in emulator output
+- Verify terminal has correct permissions
+
+**"Frozen script not executing"**
+- Verify FROZEN_SCRIPT path is correct
+- Ensure you did `make clean all` after changing script
+- Check script has no syntax errors (test locally first)
+
+**"Out of memory"**
+- Increase RAM: `--ram-size=8192` (8MB)
+- GC heap is fixed at 2MB in linker script
+- Reduce script complexity or data structures
+
+---
+
+## Technical Details
+
+### Memory Layout
+
 ```
-./riscv-emu.py --raw-tty --ram-size=4096 prebuilt/micropython.elf 
+0x00000000: .text (code)
+0x0000xxxx: .rodata (constants)
+0x0000xxxx: .data (initialized globals)
+0x0000xxxx: .bss (uninitialized globals)
+0x0000xxxx: GC heap (2MB for MicroPython)
+0x00200000: Newlib heap start
+0x003C0000: Stack (512KB from top of 4MB RAM)
+0x00400000: Top of RAM (4MB default)
 ```
+
+### UART Register Map
+
+```
+Base: 0x10000000
+
++0x00  TX (write-only)  - Write byte to transmit
++0x04  RX (read-only)   - Read received byte
+                        - Bit 31: 1 = no data, 0 = data available
+                        - Bits 7-0: received byte
+```
+
+### Frozen Module Details
+
+1. **Python → .mpy**: `mpy-cross` compiles Python to bytecode
+2. **.mpy → C**: `mpy-tool.py` generates `_frozen_mpy.c`
+3. **C → binary**: Compiled and linked into firmware
+4. **Runtime**: `pyexec_frozen_module("startup", false)` executes it
+
+Module name is derived from filename: `startup.py` → `"startup"`
+
+---
+
+## File Structure
+
+```
+port-riscv-emu.py/
+├── main.c                  # Entry point, mode-conditional execution
+├── mpconfigport.h          # MicroPython configuration, mode definitions
+├── Makefile                # Build system with MODE selection
+│
+├── mphalport.c             # HAL: syscall I/O (Mode 1)
+├── mphalport_uart.c        # HAL: UART MMIO (Modes 3,4)
+├── mphalport_silent.c      # HAL: silent/no-op (Mode 2)
+│
+├── start_newlib.S          # Startup code (Newlib initialization)
+├── syscalls_newlib.S       # Syscall interface
+├── linker_newlib.ld        # Linker script
+│
+├── startup.py              # Example frozen script
+├── uart_demo.py            # uctypes UART demo
+├── uart_repl.py            # Python REPL via uctypes
+│
+└── README.md               # This file
+```
+
+---
+
+## Resources
+
+- **MicroPython Documentation**: https://docs.micropython.org/
+- **uctypes module**: https://docs.micropython.org/en/latest/library/uctypes.html
+- **Frozen modules**: https://docs.micropython.org/en/latest/reference/manifest.html
+- **Emulator**: ../../riscv-emu.py
+- **Detailed mode docs**: README_MODES.md
+
+---
+
+## License
+
+This port follows the MicroPython license (MIT). See the MicroPython repository for details.
diff --git a/advanced/micropython/port-riscv-emu.py/Makefile b/advanced/micropython/port-riscv-emu.py/Makefile
index 2a8e12c..80f1bdc 100644
--- a/advanced/micropython/port-riscv-emu.py/Makefile
+++ b/advanced/micropython/port-riscv-emu.py/Makefile
@@ -8,6 +8,13 @@ QSTR_DEFS = qstrdefsport.h
 # MicroPython feature configurations
 MICROPY_ROM_TEXT_COMPRESSION ?= 1
 
+# Mode selection (default to REPL_SYSCALL for backwards compatibility)
+# Valid values: REPL_SYSCALL, EMBEDDED_SILENT, REPL_UART, EMBEDDED_UART
+MODE ?= REPL_SYSCALL
+
+# Script to embed (for EMBEDDED_SILENT and EMBEDDED_UART modes)
+FROZEN_SCRIPT ?= startup.py
+
 # include py core make definitions
 include $(TOP)/py/py.mk
 
@@ -15,6 +22,24 @@ ifeq ($(CROSS), 1)
 CROSS_COMPILE ?= riscv64-unknown-elf-
 endif
 
+# Mode-specific configuration
+ifeq ($(MODE),REPL_SYSCALL)
+    MODE_FLAG = MODE_REPL_SYSCALL
+else ifeq ($(MODE),EMBEDDED_SILENT)
+    MODE_FLAG = MODE_EMBEDDED_SILENT
+else ifeq ($(MODE),REPL_UART)
+    MODE_FLAG = MODE_REPL_UART
+else ifeq ($(MODE),EMBEDDED_UART)
+    MODE_FLAG = MODE_EMBEDDED_UART
+else
+    $(error Invalid MODE=$(MODE). Valid values: REPL_SYSCALL, EMBEDDED_SILENT, REPL_UART, EMBEDDED_UART)
+endif
+
+# MicroPython build tools
+MPY_CROSS ?= $(TOP)/mpy-cross/build/mpy-cross
+MPY_TOOL ?= $(PYTHON) $(TOP)/tools/mpy-tool.py
+
+
 # Extension options - set to 1 to enable, 0 to disable
 # Note: the toolchain might not support all combinations
 RVM ?= 1  # Multiply/Divide (M extension)
@@ -34,12 +59,14 @@ ifeq ($(CROSS), 1)
 DFU = $(TOP)/tools/dfu.py
 PYDFU = $(TOP)/tools/pydfu.py
 CFLAGS_RISCV  = -march=$(MARCH) -mabi=ilp32 -D_REENT_SMALL
-CFLAGS += $(INC) -Wall -Werror -std=c99 $(CFLAGS_RISCV) $(COPT) #-O2
+CFLAGS += $(INC) -Wall -Werror -std=c99 $(CFLAGS_RISCV) $(COPT) -DMICROPY_PORT_MODE=$(MODE_FLAG)
+# All modes use Newlib linker script and specs
 LDFLAGS += -nostartfiles -static -Tlinker_newlib.ld --specs=nosys.specs
 else
 UNAME_S := $(shell uname -s)
 LD = $(CC)
-CFLAGS += $(INC) -Wall -Werror -Wdouble-promotion -Wfloat-conversion -std=c99 $(COPT)
+CFLAGS += $(INC) -Wall -Werror -Wdouble-promotion -Wfloat-conversion -std=c99 $(COPT) -DMICROPY_PORT_MODE=$(MODE_FLAG)
+# All modes use Newlib
 ifeq ($(UNAME_S),Linux)
 LDFLAGS += -nostartfiles -Wl,--gc-sections -static -Tlinker_newlib.ld --specs=nano.specs -Wl,-map,$@.map -Wl,-dead_strip
 else ifeq ($(UNAME_S),Darwin)
@@ -61,31 +88,43 @@ endif
 # Flags for optional C++ source code
 CXXFLAGS += $(filter-out -std=c99,$(CFLAGS))
 
-LIBS = -lm
+# Libraries (all modes use Newlib)
+# Need libgcc for 64-bit integer ops, libc for standard functions, libm for math
+LIBS = -lc -lm -lgcc
 
+# Common source files for all modes
 SRC_C = \
 	main.c \
-	minimal_stubs.c \
 	gccollect.c \
-	mphalport.c \
-	shared/libc/printf.c \
 	shared/readline/readline.c \
 	shared/runtime/pyexec.c \
 	shared/runtime/gchelper_native.c \
 	shared/runtime/stdout_helpers.c \
 	extmod/moductypes.c
 
+# Mode-specific source files
+# All modes use Newlib startup and syscalls (since we link Newlib libraries)
+SRC_C += minimal_stubs.c shared/libc/printf.c
+SRC_S = start_newlib.S syscalls_newlib.S gchelper_rv32i.S
+
+# Select HAL based on mode
+ifeq ($(MODE),REPL_SYSCALL)
+    # Mode 1: syscall-based I/O
+    SRC_C += mphalport.c
+else ifeq ($(MODE),EMBEDDED_SILENT)
+    # Mode 2: silent (no I/O)
+    SRC_C += mphalport_silent.c
+else
+    # Modes 3,4: UART MMIO I/O
+    SRC_C += mphalport_uart.c
+endif
+
 ifeq ($(CROSS), 1)
 SRC_C += shared/libc/string0.c
 endif
 
 SRC_QSTR += shared/readline/readline.c shared/runtime/pyexec.c extmod/moductypes.c
 
-SRC_S = \
-	start_newlib.S \
-    syscalls_newlib.S \
-	gchelper_rv32i.S
-
 OBJ += $(PY_CORE_O)
 OBJ += $(addprefix $(BUILD)/, $(SRC_C:.c=.o))
 OBJ += $(addprefix $(BUILD)/, $(SRC_S:.S=.o))
@@ -97,9 +136,9 @@ else
 all: $(BUILD)/firmware.elf
 endif
 
-$(BUILD)/_frozen_mpy.c: $(TOP)/tests/frozen/frozentest.mpy $(BUILD)/genhdr/qstrdefs.generated.h
-	$(ECHO) "MISC freezing bytecode"
-	$(Q)$(TOP)/tools/mpy-tool.py -f -q $(BUILD)/genhdr/qstrdefs.preprocessed.h -mlongint-impl=none $< > $@
+# Print build configuration
+$(info Building MicroPython port in MODE=$(MODE))
+
 
 $(BUILD)/firmware.elf: $(OBJ)
 	$(ECHO) "LINK $@"
@@ -129,3 +168,30 @@ test: $(BUILD)/firmware.elf
 	$(Q)/usr/bin/printf "print('hello world!', list(x+1 for x in range(10)), end='eol\\\\n')\\r\\n\\004" | $(BUILD)/firmware.elf | tail -n2 | grep "^hello world! \\[1, 2, 3, 4, 5, 6, 7, 8, 9, 10\\]eol"
 
 include $(TOP)/py/mkrules.mk
+
+# Frozen module support for embedded modes
+ifeq ($(MODE),EMBEDDED_SILENT)
+    FROZEN_ENABLED = 1
+else ifeq ($(MODE),EMBEDDED_UART)
+    FROZEN_ENABLED = 1
+else
+    FROZEN_ENABLED = 0
+endif
+
+ifeq ($(FROZEN_ENABLED),1)
+    # Compile Python script to .mpy bytecode
+    $(BUILD)/$(FROZEN_SCRIPT:.py=.mpy): $(FROZEN_SCRIPT)
+	$(ECHO) "MPY $(FROZEN_SCRIPT)"
+	$(Q)$(MPY_CROSS) -o $@ -s $(FROZEN_SCRIPT) $<
+
+    # Generate C code from .mpy bytecode
+    $(BUILD)/_frozen_mpy.c: $(BUILD)/$(FROZEN_SCRIPT:.py=.mpy) $(BUILD)/genhdr/qstrdefs.generated.h
+	$(ECHO) "MISC freezing bytecode"
+	$(Q)$(MPY_TOOL) -f -q $(BUILD)/genhdr/qstrdefs.preprocessed.h -mlongint-impl=longlong $< > $@
+
+    # Add frozen module C file to sources
+    SRC_C += $(BUILD)/_frozen_mpy.c
+    
+    # Make firmware depend on frozen module
+    $(BUILD)/firmware.elf: $(BUILD)/_frozen_mpy.c
+endif
diff --git a/advanced/micropython/port-riscv-emu.py/README_MODES.md b/advanced/micropython/port-riscv-emu.py/README_MODES.md
new file mode 100644
index 0000000..f3a54cf
--- /dev/null
+++ b/advanced/micropython/port-riscv-emu.py/README_MODES.md
@@ -0,0 +1,403 @@
+# MicroPython Port - Build Modes
+
+This MicroPython port supports 4 configurable build modes, selectable at compile time via the `MODE` Makefile variable.
+
+## Overview
+
+| Mode | Description | Newlib | I/O Method | REPL | Frozen Script | Use Case |
+|------|-------------|--------|------------|------|---------------|----------|
+| **REPL_SYSCALL** | Interactive REPL with syscalls | ✅ Yes | read()/write() syscalls | ✅ Yes | ❌ No | Development, testing |
+| **EMBEDDED_SILENT** | Run frozen script, no I/O | ❌ No | Silent (no-op) | ❌ No | ✅ Yes | Bare-metal, computation only |
+| **REPL_UART** | Interactive REPL over UART | ❌ No | UART MMIO | ✅ Yes | ❌ No | Embedded with UART |
+| **EMBEDDED_UART** | Frozen script + UART REPL | ❌ No | UART MMIO | ✅ Yes | ✅ Yes | Embedded init + debug |
+
+---
+
+## Mode 1: REPL_SYSCALL (Default)
+
+**Current behavior** - Interactive REPL using system calls for I/O.
+
+### Build
+```bash
+cd port-riscv-emu.py
+make MODE=REPL_SYSCALL
+# or just
+make
+```
+
+### Run
+```bash
+../../riscv-emu.py --raw-tty --ram-size=4096 build/firmware.elf
+```
+
+### Features
+- Full interactive REPL
+- Uses `read(0)` and `write(1)` syscalls (ecall to emulator)
+- Links against Newlib
+- Welcome message on startup
+- Standard Python print() and input()
+
+### Memory Layout
+- Newlib linked (includes printf, malloc stubs, etc.)
+- Uses syscalls for all I/O
+- GC heap: 2MB fixed (defined in linker)
+- Stack: 512KB
+
+---
+
+## Mode 2: EMBEDDED_SILENT
+
+**Zero syscalls** - Runs a frozen Python script with no I/O.
+
+### Build
+```bash
+cd port-riscv-emu.py
+make MODE=EMBEDDED_SILENT FROZEN_SCRIPT=startup.py clean all
+```
+
+### Run
+```bash
+../../riscv-emu.py --ram-size=4096 build/firmware.elf
+```
+
+### Features
+- Executes embedded Python script at startup
+- **No syscalls** - can run in completely bare-metal environment
+- No Newlib - smaller binary
+- Silent mode: all print() output discarded
+- No REPL - exits after script completes
+- Smallest binary size
+
+### Use Cases
+- Pure computation (crypto, algorithms, data processing)
+- Environments without I/O devices
+- ROM-based systems
+- Deterministic embedded scripts
+
+### Script Embedding
+The Python script specified by `FROZEN_SCRIPT` is compiled to bytecode and embedded in the firmware binary at build time.
+
+**Note**: Frozen module support (TODO) will be added to execute the embedded script.
+
+---
+
+## Mode 3: REPL_UART
+
+**UART MMIO** - Interactive REPL over memory-mapped UART, no syscalls.
+
+### Build
+```bash
+cd port-riscv-emu.py
+make MODE=REPL_UART clean all
+```
+
+### Run
+```bash
+# Start emulator with UART peripheral
+../../riscv-emu.py --uart --ram-size=4096 build/firmware.elf
+
+# The emulator will print the PTY device name, e.g.:
+# [UART] PTY created: /dev/pts/X
+
+# In another terminal, connect to the UART:
+screen /dev/pts/X
+# or
+picocom /dev/pts/X
+```
+
+### Features
+- Full interactive REPL over UART
+- **No syscalls** - all I/O via MMIO registers
+- UART at memory address 0x10000000
+- No Newlib - smaller binary
+- Welcome message on startup
+- Standard Python REPL experience
+
+### UART Register Map
+```
+Base Address: 0x10000000
+
+Offset  | Register | Access | Description
+--------|----------|--------|---------------------------
+0x00    | TX       | Write  | Write byte to transmit
+0x04    | RX       | Read   | Read received byte
+                             | Bit 31 = 1 if no data available
+```
+
+### Use Cases
+- Embedded systems with UART
+- Minimal I/O overhead
+- Hardware without full syscall support
+- Smaller binary than REPL_SYSCALL mode
+
+---
+
+## Mode 4: EMBEDDED_UART
+
+**Init script + UART REPL** - Runs frozen script then drops to UART REPL.
+
+### Build
+```bash
+cd port-riscv-emu.py
+make MODE=EMBEDDED_UART FROZEN_SCRIPT=startup.py clean all
+```
+
+### Run
+```bash
+# Start emulator with UART peripheral
+../../riscv-emu.py --uart --ram-size=4096 build/firmware.elf
+
+# Connect to PTY in another terminal
+screen /dev/pts/X
+```
+
+### Features
+- Executes embedded initialization script first
+- Then starts interactive REPL over UART
+- **No syscalls** - all I/O via UART MMIO
+- No Newlib - smaller binary
+- Persistent state from init script available in REPL
+
+### Use Cases
+- Embedded systems requiring initialization
+- Device configuration + interactive debug
+- Boot scripts with fallback to REPL
+- Production systems with debug console
+
+### Example Workflow
+1. `startup.py` initializes hardware, loads config, starts services
+2. REPL starts for debugging/inspection
+3. Can examine variables, test functions, modify behavior
+4. Production build can disable REPL by switching to EMBEDDED_SILENT
+
+---
+
+## Implementation Details
+
+### Architecture
+
+The mode system is implemented through:
+
+1. **Compile-time selection** (`Makefile`)
+   - `MODE` variable selects configuration
+   - Conditional source file inclusion
+   - Different linker scripts
+   - MODE flag passed to C preprocessor
+
+2. **Configuration** (`mpconfigport.h`)
+   - Mode constants defined
+   - Frozen module support enabled for embedded modes
+   - Conditional feature flags
+
+3. **Conditional execution** (`main.c`)
+   - Welcome message for REPL modes only
+   - Frozen script execution for embedded modes
+   - REPL started based on mode
+
+4. **HAL abstraction** (mphalport_*.c)
+   - `mphalport.c` - syscalls (Mode 1)
+   - `mphalport_uart.c` - UART MMIO (Modes 3, 4)
+   - `mphalport_silent.c` - no-op stubs (Mode 2)
+
+5. **Startup code**
+   - `start_newlib.S` - Newlib initialization (Mode 1)
+   - `start_nolib.S` - Minimal startup (Modes 2, 3, 4)
+
+6. **Linker scripts**
+   - `linker_newlib.ld` - With Newlib heap (Mode 1)
+   - `linker_nolib.ld` - No Newlib, simpler layout (Modes 2, 3, 4)
+
+### File Map
+
+| File | Mode 1 | Mode 2 | Mode 3 | Mode 4 |
+|------|--------|--------|--------|--------|
+| main.c | ✅ | ✅ | ✅ | ✅ |
+| mphalport.c | ✅ | ❌ | ❌ | ❌ |
+| mphalport_uart.c | ❌ | ❌ | ✅ | ✅ |
+| mphalport_silent.c | ❌ | ✅ | ❌ | ❌ |
+| minimal_stubs.c | ✅ | ❌ | ❌ | ❌ |
+| minimal_nolib.c | ❌ | ✅ | ✅ | ✅ |
+| start_newlib.S | ✅ | ❌ | ❌ | ❌ |
+| start_nolib.S | ❌ | ✅ | ✅ | ✅ |
+| syscalls_newlib.S | ✅ | ❌ | ❌ | ❌ |
+| linker_newlib.ld | ✅ | ❌ | ❌ | ❌ |
+| linker_nolib.ld | ❌ | ✅ | ✅ | ✅ |
+
+### Memory Allocation
+
+All modes use **MicroPython's garbage collector** with a fixed 2MB heap:
+- Defined in linker script: `.gc_heap` section
+- Initialized with `gc_init(&_gc_heap_start, &_gc_heap_end)`
+- **No sbrk dependency** - heap is pre-allocated
+- Newlib's malloc/free are NOT used by MicroPython core
+
+### Syscall Dependencies
+
+| Component | Mode 1 | Mode 2 | Mode 3 | Mode 4 |
+|-----------|--------|--------|--------|--------|
+| GC/malloc | ❌ None | ❌ None | ❌ None | ❌ None |
+| stdout | ✅ write(1) | ❌ None | ❌ None | ❌ None |
+| stdin | ✅ read(0) | ❌ None | ❌ None | ❌ None |
+| Newlib | ✅ sbrk, etc | ❌ None | ❌ None | ❌ None |
+
+**Summary**: Modes 2, 3, 4 have **zero syscall dependencies** and can run in completely bare-metal environments.
+
+---
+
+## Build System
+
+### Makefile Variables
+
+```makefile
+MODE=<mode>          # REPL_SYSCALL, EMBEDDED_SILENT, REPL_UART, EMBEDDED_UART
+FROZEN_SCRIPT=<path> # Path to Python script to embed (Modes 2, 4)
+DEBUG=1              # Enable debug build (default: optimized)
+RVM=1                # Enable RISC-V M extension (multiply/divide)
+RVA=1                # Enable RISC-V A extension (atomic)
+RVC=1                # Enable RISC-V C extension (compressed)
+```
+
+### Examples
+
+```bash
+# Default mode (REPL with syscalls)
+make
+
+# Embedded silent mode with custom script
+make MODE=EMBEDDED_SILENT FROZEN_SCRIPT=my_app.py clean all
+
+# UART REPL with debug symbols
+make MODE=REPL_UART DEBUG=1 clean all
+
+# Embedded UART with all RISC-V extensions
+make MODE=EMBEDDED_UART RVM=1 RVA=1 RVC=1 clean all
+```
+
+### Clean Builds
+
+**Always use `clean all` when changing MODE** to ensure all source files are recompiled with correct configuration:
+
+```bash
+make MODE=REPL_UART clean all
+```
+
+---
+
+## TODO: Frozen Module Support
+
+Currently, the frozen script execution is marked as TODO in `main.c:32-33`. To complete this:
+
+1. Enable MicroPython's mpy-tool.py integration
+2. Generate `_frozen_mpy.c` from `FROZEN_SCRIPT`
+3. Link frozen bytecode into binary
+4. Call `pyexec_frozen_module()` in main.c
+
+Alternative approaches:
+- Use `mp_lexer_new_from_str_len()` with script embedded as C string
+- Implement simple script loader from memory
+
+---
+
+## Binary Size Comparison
+
+Estimated sizes (to be measured after building):
+
+| Mode | Newlib | Estimated Size | Notes |
+|------|--------|---------------|-------|
+| REPL_SYSCALL | Yes | ~500 KB | Largest (Newlib + printf) |
+| EMBEDDED_SILENT | No | ~350 KB | Smallest (no I/O, no Newlib) |
+| REPL_UART | No | ~400 KB | Medium (UART HAL, no Newlib) |
+| EMBEDDED_UART | No | ~420 KB | Medium (frozen + UART) |
+
+---
+
+## Testing
+
+### Mode 1 - REPL_SYSCALL
+```bash
+make clean all
+../../riscv-emu.py --raw-tty --ram-size=4096 build/firmware.elf
+# Should see: "Welcome to MicroPython on RISC-V!"
+# Type: print("Hello")
+```
+
+### Mode 2 - EMBEDDED_SILENT
+```bash
+make MODE=EMBEDDED_SILENT FROZEN_SCRIPT=startup.py clean all
+../../riscv-emu.py --ram-size=4096 build/firmware.elf
+# Should run silently and exit (once frozen module support is complete)
+```
+
+### Mode 3 - REPL_UART
+```bash
+make MODE=REPL_UART clean all
+# Terminal 1:
+../../riscv-emu.py --uart --ram-size=4096 build/firmware.elf
+# Note the PTY device shown
+
+# Terminal 2:
+screen /dev/pts/X  # Replace X with actual number
+# Should see REPL prompt
+```
+
+### Mode 4 - EMBEDDED_UART
+```bash
+make MODE=EMBEDDED_UART FROZEN_SCRIPT=startup.py clean all
+# Terminal 1:
+../../riscv-emu.py --uart --ram-size=4096 build/firmware.elf
+
+# Terminal 2:
+screen /dev/pts/X
+# Should see startup script output, then REPL prompt
+```
+
+---
+
+## Troubleshooting
+
+### MicroPython submodule not initialized
+```bash
+cd ../micropython
+git submodule update --init
+```
+
+### Build errors about missing files
+Ensure you're in the correct directory:
+```bash
+cd port-riscv-emu.py
+```
+
+### UART connection issues
+Check the PTY device name in emulator output and ensure screen/picocom has permissions:
+```bash
+ls -l /dev/pts/X
+sudo usermod -a -G dialout $USER  # If needed
+```
+
+### MODE changes not taking effect
+Always clean before switching modes:
+```bash
+make MODE=<new_mode> clean all
+```
+
+---
+
+## Future Enhancements
+
+1. **Frozen module system** - Complete the script embedding
+2. **Multiple frozen modules** - Support importing frozen libraries
+3. **Dynamic script loading** - Option 2A from original analysis (file-based loading)
+4. **Flash emulation** - Persistent storage for scripts
+5. **Additional peripherals** - GPIO, SPI, I2C via MMIO
+6. **Power management** - WFI-based sleep in silent mode
+7. **Custom allocators** - Fine-tune memory for constrained environments
+
+---
+
+## References
+
+- MicroPython documentation: https://docs.micropython.org/
+- RISC-V specifications: https://riscv.org/technical/specifications/
+- Newlib documentation: https://sourceware.org/newlib/
+- Emulator source: ../../riscv-emu.py
+- Peripheral implementations: ../../peripherals.py
diff --git a/advanced/micropython/port-riscv-emu.py/linker_nolib.ld b/advanced/micropython/port-riscv-emu.py/linker_nolib.ld
new file mode 100644
index 0000000..0d61065
--- /dev/null
+++ b/advanced/micropython/port-riscv-emu.py/linker_nolib.ld
@@ -0,0 +1,68 @@
+ENTRY(_start)
+
+MEMORY
+{
+  RAM (rwx) : ORIGIN = 0x00000000, LENGTH = 4M
+}
+
+SECTIONS
+{
+  .text : ALIGN(4)
+  {
+    KEEP(*(.init))
+    KEEP(*(.text.startup))
+    *(.text*)
+  } > RAM
+
+  .rodata : ALIGN(4)
+  {
+    KEEP(*(.rodata*))
+    KEEP(*(.srodata*))
+  } > RAM
+
+  .data : ALIGN(4)
+  {
+    *(.data*)
+  } > RAM
+
+  .sdata : ALIGN(4)
+  {
+    __global_pointer$ = . + 0x800;  /* required for gp-relative addressing */
+    *(.sdata*)
+  } > RAM
+
+  .bss : ALIGN(8)
+  {
+    __bss_start = .;
+    *(.bss*)
+    *(COMMON)
+    __bss_end = .;
+  } > RAM
+
+  .sbss : ALIGN(4)
+  {
+    __sbss_start = .;
+    *(.sbss*)
+    __sbss_end = .;
+  } > RAM
+
+  .gc_heap (NOLOAD) : ALIGN(4) {
+    __gc_heap_start = .;
+    . = . + 0x200000;  /* 2 MB for MicroPython GC */
+     __gc_heap_end = .;
+  } > RAM
+
+  /* Stack region - no Newlib heap needed */
+  . = ALIGN(8);
+  end = .;
+
+  __stack_top = ORIGIN(RAM) + LENGTH(RAM);
+  __stack_bottom = __stack_top - 512K;
+
+  PROVIDE(_end = end);
+  PROVIDE(_gc_heap_start = __gc_heap_start);
+  PROVIDE(_gc_heap_end = __gc_heap_end);
+  PROVIDE(_stack_top = __stack_top);
+  PROVIDE(_stack_bottom = __stack_bottom);
+  PROVIDE(_global_pointer$ = __global_pointer$);
+}
diff --git a/advanced/micropython/port-riscv-emu.py/main.c b/advanced/micropython/port-riscv-emu.py/main.c
index d5fd469..72f2af8 100644
--- a/advanced/micropython/port-riscv-emu.py/main.c
+++ b/advanced/micropython/port-riscv-emu.py/main.c
@@ -5,6 +5,7 @@
 #include "py/objlist.h"
 #include "shared/runtime/pyexec.h"
 #include "shared/runtime/gchelper.h"
+#include "mpconfigport.h"
 
 extern uint8_t _gc_heap_start, _gc_heap_end;
 
@@ -19,9 +20,24 @@ int main(int argc, char *argv[]) {
 		mp_obj_list_append(mp_sys_argv, mp_obj_new_str(argv[i], strlen(argv[i])));
     }
 
+#if (MICROPY_PORT_MODE == MODE_REPL_SYSCALL) || \
+    (MICROPY_PORT_MODE == MODE_REPL_UART)
+    // Welcome message for REPL-only modes
     mp_printf(&mp_plat_print, "Welcome to MicroPython on RISC-V!\n");
+#endif
 
+#if (MICROPY_PORT_MODE == MODE_EMBEDDED_SILENT) || \
+    (MICROPY_PORT_MODE == MODE_EMBEDDED_UART)
+    // Execute frozen script
+    pyexec_frozen_module("startup", false);
+#endif
+
+#if (MICROPY_PORT_MODE == MODE_REPL_SYSCALL) || \
+    (MICROPY_PORT_MODE == MODE_REPL_UART) || \
+    (MICROPY_PORT_MODE == MODE_EMBEDDED_UART)
+    // Start REPL
 	pyexec_friendly_repl();
+#endif
 
     gc_sweep_all();
     mp_deinit();
diff --git a/advanced/micropython/port-riscv-emu.py/minimal_nolib.c b/advanced/micropython/port-riscv-emu.py/minimal_nolib.c
new file mode 100644
index 0000000..ab14c90
--- /dev/null
+++ b/advanced/micropython/port-riscv-emu.py/minimal_nolib.c
@@ -0,0 +1,71 @@
+#include "py/obj.h"
+#include "py/lexer.h"
+#include "py/stream.h"
+#include "py/runtime.h"
+#include "py/builtin.h"
+#include "py/mpprint.h"
+
+// Stub: If nlr fails, just halt (no printf, no Newlib)
+void nlr_jump_fail(void *val) {
+    (void)val;
+    // Silent failure - just loop forever
+    while (1) {
+        __asm__ volatile ("wfi");  // Wait for interrupt (low power)
+    }
+}
+
+// Stub: We have no filesystem
+mp_import_stat_t mp_import_stat(const char *path) {
+    (void)path;
+    return MP_IMPORT_STAT_NO_EXIST;
+}
+
+// Stub: no file-based imports
+mp_lexer_t *mp_lexer_new_from_file(qstr filename) {
+    (void)filename;
+    // Silent failure
+    return NULL;
+}
+
+static mp_uint_t mp_dummy_stream_read(mp_obj_t self, void *buf, mp_uint_t size, int *errcode) {
+    (void)self;
+    (void)buf;
+    (void)size;
+    *errcode = MP_EIO;
+    return MP_STREAM_ERROR;
+}
+
+static mp_uint_t mp_dummy_stream_write(mp_obj_t self, const void *buf, mp_uint_t size, int *errcode) {
+    (void)self;
+    (void)buf;
+    (void)size;
+    *errcode = MP_EIO;
+    return MP_STREAM_ERROR;
+}
+
+static void mp_dummy_stream_print(const mp_print_t *print, mp_obj_t self, mp_print_kind_t kind) {
+    (void)self;
+    (void)kind;
+    mp_print_str(print, "<dummy_stream>");
+}
+
+// Stream protocol table
+static const mp_stream_p_t dummy_stream_p = {
+    .read = mp_dummy_stream_read,
+    .write = mp_dummy_stream_write,
+    .is_text = false,
+};
+
+// Object type using new macro
+MP_DEFINE_CONST_OBJ_TYPE(
+    mp_dummy_stream_type,
+    MP_QSTR_dummy_stream,
+    MP_TYPE_FLAG_NONE,
+    print, mp_dummy_stream_print,
+    protocol, &dummy_stream_p
+);
+
+const mp_obj_base_t mp_sys_stdin_obj  = { &mp_dummy_stream_type };
+const mp_obj_base_t mp_sys_stdout_obj = { &mp_dummy_stream_type };
+const mp_obj_base_t mp_sys_stderr_obj = { &mp_dummy_stream_type };
+
diff --git a/advanced/micropython/port-riscv-emu.py/mpconfigport.h b/advanced/micropython/port-riscv-emu.py/mpconfigport.h
index 4a2d567..9275967 100644
--- a/advanced/micropython/port-riscv-emu.py/mpconfigport.h
+++ b/advanced/micropython/port-riscv-emu.py/mpconfigport.h
@@ -2,7 +2,31 @@
 
 // options to control how MicroPython is built
 
-#define MICROPY_CONFIG_ROM_LEVEL (MICROPY_CONFIG_ROM_LEVEL_EXTRA_FEATURES)
+// Mode definitions (set via Makefile)
+#define MODE_REPL_SYSCALL    1  // REPL with syscalls
+#define MODE_EMBEDDED_SILENT 2  // Frozen script, no I/O
+#define MODE_REPL_UART       3  // REPL over UART MMIO
+#define MODE_EMBEDDED_UART   4  // Frozen script + UART REPL
+
+#ifndef MICROPY_PORT_MODE
+#define MICROPY_PORT_MODE MODE_REPL_SYSCALL
+#endif
+
+// Use CORE_FEATURES ROM level as base, then explicitly enable what we need
+#define MICROPY_CONFIG_ROM_LEVEL (MICROPY_CONFIG_ROM_LEVEL_CORE_FEATURES)
+
+// Float support: only for REPL_SYSCALL mode
+#if (MICROPY_PORT_MODE == MODE_REPL_SYSCALL)
+    #define MICROPY_PY_BUILTINS_FLOAT         (1)
+    #define MICROPY_FLOAT_IMPL                (MICROPY_FLOAT_IMPL_FLOAT)
+    #define MICROPY_PY_MATH                   (1)
+    #define MICROPY_PY_CMATH                  (0)
+#else
+    #define MICROPY_PY_BUILTINS_FLOAT         (0)
+    #define MICROPY_FLOAT_IMPL                (MICROPY_FLOAT_IMPL_NONE)
+    #define MICROPY_PY_MATH                   (0)
+    #define MICROPY_PY_CMATH                  (0)
+#endif
 
 #define MICROPY_ENABLE_COMPILER     (1)
 #define MICROPY_ENAVLE_REPL	        (1)
@@ -12,7 +36,15 @@
 #define MICROPY_ENABLE_GC                 (1)
 #define MICROPY_HELPER_REPL               (1)
 #define MICROPY_ENABLE_REPL_HELPERS       (1)
-#define MICROPY_MODULE_FROZEN_MPY         (0)
+
+// Enable frozen modules for embedded modes
+#if (MICROPY_PORT_MODE == MODE_EMBEDDED_SILENT) || \
+    (MICROPY_PORT_MODE == MODE_EMBEDDED_UART)
+    #define MICROPY_MODULE_FROZEN_MPY         (1)
+#else
+    #define MICROPY_MODULE_FROZEN_MPY         (0)
+#endif
+
 #define MICROPY_ENABLE_EXTERNAL_IMPORT    (0)
 #define MICROPY_KBD_EXCEPTION             (1)
 
@@ -22,19 +54,25 @@
 #define MICROPY_PY_BUILTINS_HELP_MODULES  (1)
 #define MICROPY_PY_GC                     (1)
 #define MICROPY_PY_BUILTINS_STR_UNICODE   (1)
-#define MICROPY_PY_BUILTINS_FLOAT         (1)
+
 #define MICROPY_LONGINT_IMPL              (MICROPY_LONGINT_IMPL_LONGLONG)
-#define MICROPY_FLOAT_IMPL                (MICROPY_FLOAT_IMPL_FLOAT)
 #define MICROPY_PY_BUILTINS_COMPLEX       (0)
 #define MICROPY_PY_IO                     (0)  // no file system or streams
+
+// Explicitly enable modules we need (some may not be in CORE_FEATURES)
 #define MICROPY_PY_ARRAY                  (1)
 #define MICROPY_PY_COLLECTIONS            (1)
-#define MICROPY_PY_MATH                   (1)
+#define MICROPY_PY_COLLECTIONS_DEQUE      (1)
+#define MICROPY_PY_COLLECTIONS_ORDEREDDICT (1)
 #define MICROPY_PY_URANDOM                (1)
+#define MICROPY_PY_URANDOM_SEED_INIT_FUNC (0)
 #define MICROPY_PY_STRUCT                 (1)
 #define MICROPY_PY_ERRNO                  (1)
 #define MICROPY_PY_BINASCII               (1)
 #define MICROPY_PY_RE                     (1)
+#define MICROPY_PY_HEAPQ                  (1)
+#define MICROPY_PY_HASHLIB                (0)
+#define MICROPY_PY_JSON                   (1)
 #define MICROPY_PY_UCTYPES                (1)
 
 #define MICROPY_PY_SYS                    (1)
@@ -46,7 +84,6 @@
 #define MICROPY_PY_SYS_ARGV               (1)
 
 #define MICROPY_PY_BUILTINS_SLICE         (1)
-#define MICROPY_PY_ALL_FEATURES           (1)
 
 #define MICROPY_ALLOC_PATH_MAX            (256)
 
diff --git a/advanced/micropython/port-riscv-emu.py/mphalport_silent.c b/advanced/micropython/port-riscv-emu.py/mphalport_silent.c
new file mode 100644
index 0000000..d8a299b
--- /dev/null
+++ b/advanced/micropython/port-riscv-emu.py/mphalport_silent.c
@@ -0,0 +1,19 @@
+#include <stddef.h>
+#include "py/mpconfig.h"
+
+/*
+ * Silent I/O mode - no hardware interaction
+ * For embedded scripts that don't need I/O
+ */
+
+// Discard all output
+mp_uint_t mp_hal_stdout_tx_strn(const char *str, size_t len) {
+    (void)str;
+    (void)len;
+    return len;  // Pretend we wrote everything
+}
+
+// No input available
+int mp_hal_stdin_rx_chr(void) {
+    return -1;  // Always return "no data"
+}
diff --git a/advanced/micropython/port-riscv-emu.py/mphalport_uart.c b/advanced/micropython/port-riscv-emu.py/mphalport_uart.c
new file mode 100644
index 0000000..8523880
--- /dev/null
+++ b/advanced/micropython/port-riscv-emu.py/mphalport_uart.c
@@ -0,0 +1,33 @@
+#include <stddef.h>
+#include "py/mpconfig.h"
+
+/*
+ * UART via memory-mapped I/O
+ * Base address: 0x10000000
+ * REG_TX (0x00): Write byte to transmit
+ * REG_RX (0x04): Read byte (bit 31 set if no data available)
+ */
+
+#define UART_BASE 0x10000000
+#define UART_TX   (*(volatile unsigned int *)(UART_BASE + 0x00))
+#define UART_RX   (*(volatile unsigned int *)(UART_BASE + 0x04))
+#define UART_RX_EMPTY (1U << 31)
+
+// Send string to UART
+mp_uint_t mp_hal_stdout_tx_strn(const char *str, size_t len) {
+    for (size_t i = 0; i < len; i++) {
+        UART_TX = (unsigned char)str[i];
+    }
+    return len;
+}
+
+// Receive single character from UART (blocking)
+int mp_hal_stdin_rx_chr(void) {
+    unsigned int val;
+    // Wait until data is available
+    do {
+        val = UART_RX;
+    } while (val & UART_RX_EMPTY);
+
+    return val & 0xFF;
+}
diff --git a/advanced/micropython/port-riscv-emu.py/start_bare.S b/advanced/micropython/port-riscv-emu.py/start_bare.S
new file mode 100644
index 0000000..b1b9462
--- /dev/null
+++ b/advanced/micropython/port-riscv-emu.py/start_bare.S
@@ -0,0 +1,41 @@
+    .section .text
+    .globl _start
+
+_start:
+    .option push
+    .option norelax
+    la sp, __stack_top          # initialize the stack pointer
+    la gp, __global_pointer$    # initialize the global pointer
+    .option pop
+
+    # save a0 and a1: they are used to pass arguments to main()
+    mv s0, a0
+    mv s1, a1
+
+    # initialize .bss
+    la   a0, __bss_start
+    la   a1, __bss_end
+z_bss:
+    sw   zero, 0(a0)
+    addi a0, a0, 4
+    blt  a0, a1, z_bss
+
+    # initialize .sbss
+    la   a0, __sbss_start
+    la   a1, __sbss_end
+z_sbss:
+    sw   zero, 0(a0)
+    addi a0, a0, 4
+    blt  a0, a1, z_sbss
+
+    # restore a0 and a1
+    mv a0, s0
+    mv a1, s1
+
+    call main
+
+halt:
+    # No exit syscall - just loop forever
+1:
+    wfi                         # Wait for interrupt (low power)
+    j 1b
diff --git a/advanced/micropython/port-riscv-emu.py/startup.py b/advanced/micropython/port-riscv-emu.py/startup.py
new file mode 100644
index 0000000..2425704
--- /dev/null
+++ b/advanced/micropython/port-riscv-emu.py/startup.py
@@ -0,0 +1,37 @@
+# Example startup script for embedded MicroPython modes
+# Note: Float support disabled in non-Newlib modes
+
+print("MicroPython embedded startup script")
+print("=====================================")
+
+# Basic computation (integer only)
+result = sum([i**2 for i in range(10)])
+print("Sum of squares 0-9:", result)
+
+# Array operations
+import array
+arr = array.array('i', [1, 2, 3, 4, 5])
+print("Array:", list(arr))
+
+# Struct packing/unpacking
+import struct
+packed = struct.pack('HHL', 1, 2, 3)
+unpacked = struct.unpack('HHL', packed)
+print("Struct pack/unpack:", unpacked)
+
+# Regular expressions
+import re
+match = re.match(r'(\w+):(\d+)', 'hello:42')
+if match:
+    print("Regex match:", match.groups())
+
+# String operations
+text = "Hello from RISC-V!"
+print("Upper:", text.upper())
+print("Reversed:", text[::-1])
+
+# List comprehensions
+squares = [x*x for x in range(10)]
+print("Squares:", squares)
+
+print("\nStartup script completed successfully!")
diff --git a/advanced/micropython/port-riscv-emu.py/uart_demo.py b/advanced/micropython/port-riscv-emu.py/uart_demo.py
new file mode 100644
index 0000000..0764880
--- /dev/null
+++ b/advanced/micropython/port-riscv-emu.py/uart_demo.py
@@ -0,0 +1,81 @@
+"""
+Simple demo of uctypes for memory-mapped UART access
+For use in EMBEDDED_SILENT mode
+"""
+
+import uctypes
+
+# UART memory-mapped registers at 0x10000000
+UART_BASE = 0x10000000
+
+# Define UART register layout
+uart_layout = {
+    "TX": uctypes.UINT32 | 0x00,  # Transmit register
+    "RX": uctypes.UINT32 | 0x04,  # Receive register
+}
+
+# Create UART structure
+uart = uctypes.struct(UART_BASE, uart_layout, uctypes.LITTLE_ENDIAN)
+
+def uart_print(s):
+    """Print string to UART using uctypes"""
+    for c in s:
+        uart.TX = ord(c)
+
+# Demo
+uart_print("\r\n")
+uart_print("=" * 50 + "\r\n")
+uart_print("uctypes UART Demo\r\n")
+uart_print("=" * 50 + "\r\n")
+uart_print("\r\n")
+
+# Show direct register access
+uart_print("Direct UART register access:\r\n")
+uart_print(f"  UART base address: 0x{UART_BASE:08X}\r\n")
+uart_print(f"  TX register offset: 0x00\r\n")
+uart_print(f"  RX register offset: 0x04\r\n")
+uart_print("\r\n")
+
+# Demonstrate writing to TX register
+uart_print("Writing bytes directly to TX register:\r\n")
+for i, char in enumerate("Hello UART!"):
+    uart.TX = ord(char)
+    if i < len("Hello UART!") - 1:
+        uart_print(", ")
+uart_print("\r\n\r\n")
+
+# Show memory layout
+uart_print("UART struct layout:\r\n")
+uart_print(f"  struct address: {id(uart)}\r\n")
+uart_print(f"  TX field: uctypes.UINT32 @ +0x00\r\n")
+uart_print(f"  RX field: uctypes.UINT32 @ +0x04\r\n")
+uart_print("\r\n")
+
+# Demonstrate reading RX register
+uart_print("Reading RX register (non-blocking):\r\n")
+rx_val = uart.RX
+if rx_val & 0x80000000:
+    uart_print("  No data available (bit 31 set)\r\n")
+else:
+    uart_print(f"  Received byte: 0x{rx_val & 0xFF:02X}\r\n")
+uart_print("\r\n")
+
+# Integer array demo
+uart_print("Integer array operations (no floats):\r\n")
+data = [i * i for i in range(10)]
+uart_print(f"  Squares: {data}\r\n")
+uart_print(f"  Sum: {sum(data)}\r\n")
+uart_print("\r\n")
+
+# Struct packing demo
+import struct
+packed = struct.pack('HHL', 0xABCD, 0x1234, 0xDEADBEEF)
+uart_print("Struct packing demo:\r\n")
+uart_print(f"  Packed: {' '.join(f'{b:02X}' for b in packed)}\r\n")
+unpacked = struct.unpack('HHL', packed)
+uart_print(f"  Unpacked: {unpacked}\r\n")
+uart_print("\r\n")
+
+uart_print("=" * 50 + "\r\n")
+uart_print("Demo completed successfully!\r\n")
+uart_print("=" * 50 + "\r\n")
diff --git a/advanced/micropython/port-riscv-emu.py/uart_repl.py b/advanced/micropython/port-riscv-emu.py/uart_repl.py
new file mode 100644
index 0000000..851f8d2
--- /dev/null
+++ b/advanced/micropython/port-riscv-emu.py/uart_repl.py
@@ -0,0 +1,124 @@
+"""
+Python REPL using uctypes to access memory-mapped UART
+For use in EMBEDDED_SILENT mode - demonstrates pure Python hardware control
+"""
+
+import uctypes
+
+# UART memory-mapped registers at 0x10000000
+UART_BASE = 0x10000000
+
+# Define UART register layout
+UART_LAYOUT = {
+    "TX": uctypes.UINT32 | 0x00,  # Transmit register
+    "RX": uctypes.UINT32 | 0x04,  # Receive register (bit 31 = empty)
+}
+
+# Create UART structure
+uart = uctypes.struct(UART_BASE, UART_LAYOUT, uctypes.LITTLE_ENDIAN)
+
+# UART I/O functions
+def uart_putc(c):
+    """Write a character to UART"""
+    uart.TX = ord(c) if isinstance(c, str) else c
+
+def uart_getc():
+    """Read a character from UART (blocking)"""
+    while True:
+        val = uart.RX
+        if not (val & 0x80000000):  # Check empty bit
+            return val & 0xFF
+
+def uart_write(s):
+    """Write a string to UART"""
+    for c in s:
+        uart_putc(c)
+
+def uart_readline():
+    """Read a line from UART (until newline)"""
+    line = []
+    while True:
+        c = uart_getc()
+        if c == 0x0D or c == 0x0A:  # CR or LF
+            uart_write('\r\n')
+            break
+        elif c == 0x7F or c == 0x08:  # Backspace or DEL
+            if line:
+                line.pop()
+                uart_write('\b \b')  # Erase character on terminal
+        elif c >= 0x20 and c < 0x7F:  # Printable character
+            line.append(chr(c))
+            uart_putc(c)  # Echo
+    return ''.join(line)
+
+# Simple REPL implementation
+def repl():
+    """Python REPL using UART via uctypes"""
+    uart_write('\r\n')
+    uart_write('=' * 50 + '\r\n')
+    uart_write('Python REPL via uctypes UART\r\n')
+    uart_write('MicroPython on RISC-V (EMBEDDED_SILENT mode)\r\n')
+    uart_write('=' * 50 + '\r\n')
+    uart_write('\r\n')
+
+    # Global namespace for REPL
+    repl_globals = {'__name__': '__main__'}
+
+    # Add useful modules to namespace
+    repl_globals['uctypes'] = uctypes
+    repl_globals['uart'] = uart
+    repl_globals['uart_write'] = uart_write
+
+    while True:
+        try:
+            # Prompt
+            uart_write('>>> ')
+
+            # Read input
+            line = uart_readline()
+
+            if not line:
+                continue
+
+            # Handle special commands
+            if line == 'exit':
+                uart_write('Exiting REPL...\r\n')
+                break
+            elif line == 'help':
+                uart_write('Available: uctypes, uart, uart_write\r\n')
+                uart_write('Type exit to quit\r\n')
+                continue
+
+            # Try to evaluate as expression first
+            try:
+                result = eval(line, repl_globals)
+                if result is not None:
+                    uart_write(repr(result) + '\r\n')
+            except SyntaxError:
+                # If eval fails, try exec
+                exec(line, repl_globals)
+
+        except Exception as e:
+            uart_write('Error: ' + str(e) + '\r\n')
+
+# Demo functions accessible from REPL
+def demo_uart():
+    """Demonstrate direct UART register access"""
+    uart_write('\r\nDirect UART register access:\r\n')
+    uart_write(f'UART_BASE: 0x{UART_BASE:08X}\r\n')
+    uart_write(f'TX register: 0x{UART_BASE:08X}\r\n')
+    uart_write(f'RX register: 0x{UART_BASE+4:08X}\r\n')
+
+def demo_memory():
+    """Demonstrate uctypes memory access"""
+    # Read some memory
+    uart_write('\r\nMemory access demo:\r\n')
+    mem = uctypes.struct(0x1000, {"value": uctypes.UINT32 | 0}, uctypes.LITTLE_ENDIAN)
+    uart_write(f'Value at 0x1000: 0x{mem.value:08X}\r\n')
+
+# Main entry point
+if __name__ == '__main__':
+    # Run REPL
+    repl()
+
+    uart_write('\r\nREPL exited. System halted.\r\n')
